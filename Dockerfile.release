# Multi-stage build for RustFS release image
FROM alpine:3.18 AS build

# Build arguments
ARG TARGETARCH
ARG RELEASE

# Install dependencies for downloading and verifying binaries
RUN apk add --no-cache \
    ca-certificates \
    curl \
    bash \
    wget \
    unzip

# Create build directory
WORKDIR /build

# Map TARGETARCH to architecture format used in OSS
RUN case "${TARGETARCH}" in \
        "amd64") ARCH="x86_64" ;; \
        "arm64") ARCH="aarch64" ;; \
        *) echo "Unsupported architecture: ${TARGETARCH}" && exit 1 ;; \
    esac && \
    echo "ARCH=${ARCH}" > /build/arch.env

# Download rustfs binary package from dl.rustfs.com (release version)
RUN . /build/arch.env && \
    DOWNLOAD_BASE_URL="https://dl.rustfs.com/release" && \
    if [ -z "${RELEASE}" ] || [ "${RELEASE}" = "latest" ]; then \
        PACKAGE_NAME="rustfs-linux-${ARCH}-latest.zip"; \
    else \
        PACKAGE_NAME="rustfs-linux-${ARCH}-v${RELEASE}.zip"; \
    fi && \
    echo "Downloading ${PACKAGE_NAME} from ${DOWNLOAD_BASE_URL}..." && \
    curl -s -q "${DOWNLOAD_BASE_URL}/${PACKAGE_NAME}" -o /build/rustfs.zip && \
    unzip /build/rustfs.zip -d /build && \
    chmod +x /build/rustfs && \
    rm /build/rustfs.zip

# Install minisign for signature verification (optional, for future use)
RUN wget -O /tmp/minisign.tar.gz "https://github.com/jedisct1/minisign/releases/download/0.11/minisign-0.11-linux.tar.gz" && \
    tar -xzf /tmp/minisign.tar.gz -C /tmp && \
    mv /tmp/minisign-linux/x86_64/minisign /usr/local/bin/minisign && \
    chmod +x /usr/local/bin/minisign && \
    rm -rf /tmp/minisign*

# Verify binary signature using public key (disabled for now, enable when signatures are available)
# RUN minisign -Vqm /build/rustfs -x /build/rustfs.minisig -P "YOUR_PUBLIC_KEY_HERE"

# Verify checksums (disabled for now, enable when checksums are available)
# RUN cd /build && sha256sum -c rustfs.sha256sum

# Runtime stage
FROM alpine:3.18

# Set build arguments and labels
ARG RELEASE
ARG BUILD_DATE
ARG VCS_REF

LABEL name="RustFS" \
    vendor="RustFS Team" \
    maintainer="RustFS Team <dev@rustfs.com>" \
    version="${RELEASE}" \
    release="${RELEASE}" \
    build-date="${BUILD_DATE}" \
    vcs-ref="${VCS_REF}" \
    summary="RustFS is a high-performance distributed object storage system written in Rust, compatible with S3 API." \
    description="RustFS is a high-performance distributed object storage software built using Rust. It supports erasure coding storage, multi-tenant management, observability, and other enterprise-level features." \
    url="https://rustfs.com" \
    license="Apache-2.0"

# Install runtime dependencies
RUN apk add --no-cache \
    ca-certificates \
    curl \
    tzdata \
    bash \
    && addgroup -g 1000 rustfs \
    && adduser -u 1000 -G rustfs -s /bin/sh -D rustfs

# Environment variables
ENV RUSTFS_ACCESS_KEY_FILE=access_key \
    RUSTFS_SECRET_KEY_FILE=secret_key \
    RUSTFS_ROOT_USER_FILE=access_key \
    RUSTFS_ROOT_PASSWORD_FILE=secret_key \
    RUSTFS_CONFIG_ENV_FILE=config.env \
    RUSTFS_ADDRESS=":9000" \
    RUSTFS_CONSOLE_ENABLE=true \
    RUSTFS_VOLUMES=/data

# Set permissions for /usr/bin (similar to MinIO's approach)
RUN chmod -R 777 /usr/bin

# Copy CA certificates and binaries from build stage
COPY --from=build /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=build /build/rustfs /usr/bin/

# Copy entrypoint script
COPY scripts/scripts/entrypoint.sh /usr/bin/entrypoint.sh
RUN chmod +x /usr/bin/entrypoint.sh /usr/bin/rustfs

# Create data directory
RUN mkdir -p /data /config && chown -R rustfs:rustfs /data /config

# Switch to non-root user
USER rustfs

# Set working directory
WORKDIR /data

# Expose port
EXPOSE 9000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=40s \
    CMD curl -f http://localhost:9000/health || exit 1

# Volume for data
VOLUME ["/data"]

# Set entrypoint
ENTRYPOINT ["/usr/bin/entrypoint.sh"]
CMD ["rustfs"]
